var _col, _row, _myNumber, _totalPlayerCount, mapInfo, adjusta = 97, MAX = 65535, GetName = function () { return "PMO" }, Initialize = function (r, a, t, o) { _myNumber = r, _totalPlayerCount = a, _col = t, _row = o }, Process = function (r, a, t, o) { a = a[_myNumber], mapInfo = Util.arrangeMap(o); var e = Util.parsed2x2(r[_myNumber]), n = Util.nToa(e[0]) + Util.nToa(e[1]), s = Util.getAdj(), i = PMO(n, s, a); return i }, PMO = function (r, a, t) { function o(r) { var e = Util.getKeys(a[r]); i[r] = !0; for (var n in e) { var c = s[r].cost; if (!i.hasOwnProperty(e[n])) { var f = a[r][e[n]]; f > 0 ? (f = Math.floor(f / t) + 1, f += f % t > 0 ? 1 : 0) : f++; var v = c + f, d = s[e[n]]; d != r && v < d.cost && (s[e[n]] = { parent: r, cost: v, blockCost: f }) } } var l, h = MAX; for (var n in u) !i.hasOwnProperty(u[n]) && s[u[n]].cost < h && (l = u[n], h = s[u[n]].cost); void 0 != l && o(l) } function e(a) { var t = a; f.push(t); do t = s[t].parent, f.unshift(t); while (t != r) } function n(r) { for (var a = [], t = 0; 2 > t; t++)a.push(r.charCodeAt(t) - adjusta); return a } var r = r, a = a, s = {}, i = {}; for (var c in a) c != r ? s[c] = { parent: r, cost: MAX } : s[c] = { parent: r, cost: 1, blockCost: 1 }; var u = Util.getKeys(s), f = []; o(r); var v, d, l = MAX, h = MAX; for (var c in s) { var p = s[c].cost, g = s[c].blockCost; 0 == g && (d = c, h = p), 0 > g && l > p && (v = c, l = p) } e(void 0 === v ? d : v); var m = n(r), j = n(f[1]); return m[0] != j[0] ? m[0] < j[0] ? 2 : 0 : m[1] != j[1] ? m[1] < j[1] ? 1 : 3 : void 0 }, Util = function () { return this.make2Arr = function (r, a) { var t = []; t.length = a; for (var o = 0; o < t.length; o++) { t[o] = [], t[o].length = r; for (var e = 0; e < t[o].length; e++)t[o][e] = [] } return t }, this.merge_options = function (r, a) { var t = {}; for (var o in r) t[o] = r[o]; for (var o in a) t[o] = a[o]; return t }, this.arrangeMap = function (r) { for (var a = parsedWeight(r), t = [], o = 0; _row > o; o++) { var e = a.splice(0, _col); t.push(e) } return t }, this.parsedWeight = function (r) { for (var a = [], t = r.Length, o = 0, e = 0, n = 0, s = 0; t > s; s++)r[s] > 0 && (o += r[s], e++); n = o / e; for (var s = 0; t > s; s++) { var i = r[s]; switch (i) { case -1009: i = 6 > n ? -5 : -9; break; case -1008: i = 6 > n ? -4 : -8; break; case -1007: i = 6 > n ? -3 : -7; break; case -1006: i = -3; break; case -1005: i = -2; break; case -1004: i = -1; break; case -1003: i = -3; break; case -1002: i = -2; break; case -1001: i = -1; break; case -5: i-- , 6 > n && (i *= 1.5) }a.push(i) } return a }, this.parsed2x2 = function (r) { return [Math.floor(r / _col), r % _col] }, this.nToa = function (r) { return String.fromCharCode(r + adjusta) }, this.getAdj = function () { for (var r = {}, a = {}, t = this.nToa, o = 0; _row > o; o++)for (var e = 0; _col > e; e++) { var n = t(o, !0) + t(e); r.hasOwnProperty(n) || (r[n] = {}), e - 1 >= 0 && (adjPos = t(o, !0) + t(e - 1), adjCost = mapInfo[o][e - 1], r[n][adjPos] = adjCost, r = Util.merge(r, a)), _col > e + 1 && (adjPos = t(o, !0) + t(e + 1), adjCost = mapInfo[o][e + 1], r[n][adjPos] = adjCost, r = Util.merge(r, a)), o - 1 >= 0 && (adjPos = t(o - 1, !0) + t(e), adjCost = mapInfo[o - 1][e], r[n][adjPos] = adjCost, r = Util.merge(r, a)), _row > o + 1 && (adjPos = t(o + 1, !0) + t(e), adjCost = mapInfo[o + 1][e], r[n][adjPos] = adjCost, r = Util.merge(r, a)) } return r }, this.getKeys = function (r) { var a = []; for (var t in r) a.push(t); return a }, { arrangeMap: arrangeMap, parsed2x2: parsed2x2, nToa: nToa, getAdj: getAdj, merge: merge_options, getKeys: getKeys } }();